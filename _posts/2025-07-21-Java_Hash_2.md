---
title: "[Java/ìë£Œêµ¬ì¡°] Java - Hash(2) - ConcurrentHashMap, LinkedHashMap"
date: 2025-07-21 00:11:58 +09:00
categories: [Data Structure, ì•Œê³ ë¦¬ì¦˜]
tags: [
    Java,
    Object,
    ìë£Œêµ¬ì¡°,
    í•´ì‹œ,
    Hash,
    ì•Œê³ ë¦¬ì¦˜,
    Data Structure,
    HashMap,
    Hashtable,
    í•´ì‹œë§µ,
    ConcurrentHashMap,
    LinkedHashMap
]
---

# ì„œë¡ 

[ì§€ë‚œ Hash í¬ìŠ¤íŒ…](https://longnh214.github.io/posts/Java_Hash_1/)ì—ì„œ í•´ì‹œì™€ HashMapì— ëŒ€í•´ì„œë§Œ ì•Œì•„ë´¤ì§€ë§Œ ë¹„ìŠ·í•œ Hashtable í´ë˜ìŠ¤ë‚˜ HashMapì— íŠ¹ì • ê¸°ëŠ¥ì´ ë”í•´ì§„ ConcurrentHashMap, LinkedHashMapì— ëŒ€í•´ì„œ ì•Œì•„ë³´ê³ ì í•œë‹¤.

# Hashtable vs HashMap

`Hashtable` í´ë˜ìŠ¤ì™€ `HashMap` í´ë˜ìŠ¤ì˜ ì¼ë¶€ë¶„ì„ ì°¸ê³ í•´ì„œ ê³µí†µì ê³¼ ì°¨ì´ì ì„ ë¹„êµí•´ë³´ë ¤ê³  í•œë‹¤.

<br>

## Hashtable

```java
//...
private int threshold;

private float loadFactor;

private static class Entry<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Entry<K,V> next;
    //...
}

public synchronized V put(K key, V value) {
    // Make sure the value is not null
    if (value == null) {
        throw new NullPointerException();
    }

    // Makes sure the key is not already in the hashtable.
    Entry<?,?> tab[] = table;
    int hash = key.hashCode();
    int index = (hash & 0x7FFFFFFF) % tab.length;
    @SuppressWarnings("unchecked")
    Entry<K,V> entry = (Entry<K,V>)tab[index];
    for(; entry != null ; entry = entry.next) {
        if ((entry.hash == hash) && entry.key.equals(key)) {
            V old = entry.value;
            entry.value = value;
            return old;
        }
    }

    addEntry(hash, key, value, index);
    return null;
}
//...
```

<br>

## HashMap

```java
//...
int threshold;

final float loadFactor;

static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;
    //...
}

public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
//...
```

<br>

## ê³µí†µì ê³¼ ì°¨ì´ì 

- ê³µí†µì 
  - Hashtableì˜ Entry, HashMapì˜ Node ê°ì²´ì˜ ë‚´ë¶€ í•„ë“œëŠ” ê°™ë‹¤.
  - `loadFactor`ì™€ `threshold`ì²˜ëŸ¼ ë²„í‚·ì˜ ì„ê³„ì  ê´€ë ¨ ë³€ìˆ˜ë„ ë˜‘ê°™ì´ ê´€ë¦¬ë˜ì–´ì§„ë‹¤.
- ì°¨ì´ì 
  - ë©€í‹°ìŠ¤ë ˆë”©ì˜ ì§€ì› ìœ ë¬´
    - `Hashtable` í´ë˜ìŠ¤ëŠ” `get`, `put`, `size`, `contains`, `isEmpty` ë“± ëª¨ë“  ë©”ì†Œë“œì— `synchronized` í‚¤ì›Œë“œê°€ ë¶™ì—ˆë‹¤. ê³ ë¡œ ì„±ëŠ¥ì´ ì¢‹ì§€ ì•Šì§€ë§Œ ë©€í‹°ìŠ¤ë ˆë“œ í”„ë¡œê·¸ë˜ë°ì„ ì§€ì›í•œë‹¤.
    - `HashMap` í´ë˜ìŠ¤ëŠ” ëª¨ë“  ë©”ì†Œë“œì— `synchronized` í‚¤ì›Œë“œê°€ ì—†ì–´ ì‹±ê¸€ìŠ¤ë ˆë“œ í”„ë¡œê·¸ë˜ë°ì— ìœ ë¦¬í•˜ë‹¤.
  - `null` í—ˆìš© ì—¬ë¶€
    - Hashtableì€ `null`ì— ëŒ€í•œ í‚¤ì™€ ê°’ ëª¨ë‘ í—ˆìš©í•˜ì§€ ì•ŠëŠ”ë‹¤.
    - HashMapì€ `null`ì— ëŒ€í•œ í‚¤ì™€ ê°’ ëª¨ë‘ í—ˆìš©í•œë‹¤.

âš ï¸ `Hashtable` í´ë˜ìŠ¤ëŠ” ëª¨ë“  ë©”ì†Œë“œë¥¼ í˜¸ì¶œí•  ë•Œë§ˆë‹¤ ë½ ì²´í‚¹ ë¹„ìš©ì´ ë°œìƒí•´ì„œ ì„±ëŠ¥ì´ ê³ ë ¤ë˜ì§€ ì•Šì•˜ë‹¤.

<br>
<br>

# Collections.synchronizedMap(Map<K,V> m)

ì•„ë˜ ì½”ë“œëŠ” `Collections.java`ì˜ `synchronizedMap` ë©”ì†Œë“œ ì¼ë¶€ë¶„ì„ ê°€ì ¸ì˜¨ ê²ƒì´ë‹¤.

```java
public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m) {
    return new SynchronizedMap<>(m);
}

private static class SynchronizedMap<K,V>
    implements Map<K,V>, Serializable {
    private final Map<K,V> m; // Backing Map
    final Object mutex; // Object on which to synchronize

    public int size() {
        synchronized (mutex) {return m.size();}
    }
    public boolean isEmpty() {
        synchronized (mutex) {return m.isEmpty();}
    }
    public boolean containsKey(Object key) {
        synchronized (mutex) {return m.containsKey(key);}
    }
    public boolean containsValue(Object value) {
        synchronized (mutex) {return m.containsValue(value);}
    }
    public V get(Object key) {
        synchronized (mutex) {return m.get(key);}
    }
    //...
}
```

`Collections.synchronizedMap()`ëŠ” ë‚´ë¶€ì ìœ¼ë¡œ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ì€ Mapì„ `SynchronizedMap`ë¡œ ê°ì‹¼ë‹¤.(wrappingí•œë‹¤.)  
ë‚´ë¶€ì ìœ¼ë¡œ ìœ„ì„ ë°›ì€ ì›ë³¸ Mapì— ëŒ€í•œ ëª¨ë“  í˜¸ì¶œ ë‚´ ê° ì—°ì‚°ì— ë™ê¸°í™” ì²˜ë¦¬(ë½ ì²´í‚¹) ë¡œì§ì„ ì¶”ê°€í•œë‹¤.  
ê³ ë¡œ ì›ë³¸ Mapì— `Hashtable`ì²˜ëŸ¼ ëª¨ë“  ë©”ì†Œë“œì— ë½ ì²´í‚¹ ë¹„ìš©ì´ ì¶”ê°€ë˜ëŠ” ê°œë…ì´ë¼ê³  ë³´ë©´ ëœë‹¤.

<br>
<br>

## HashMap vs Hashtable vs ConcurrentHashMap

ìœ„ ë‚´ìš©ì—ì„œ `HashMap`ê³¼ `Hashtable`, `Collections.synchronizedMap()`ì˜ ë™ê¸°í™” ë° ìŠ¤ë ˆë“œ ì•ˆì •ì„±ì— ëŒ€í•´ì„œ ì°¨ì´ì ì„ ì•Œì•„ë³´ì•˜ë‹¤.  
`Hashtable`ê³¼ `Collections.synchronizedMap()`ì€ ìŠ¤ë ˆë“œ ì•ˆì „(Thread-safe)í•œ íŠ¹ì§•ì„ ê°€ì§€ê³  ìˆì§€ë§Œ ì½ê¸°ì™€ ì“°ê¸° ë¶€ë¶„ì—ì„œ ëª¨ë‘ ë™ê¸°í™” ì˜¤ë²„í—¤ë“œê°€ ë°œìƒí•´ì„œ ì„±ëŠ¥ ì €í•˜ë¥¼ ì¼ìœ¼í‚¬ ìˆ˜ ìˆì—ˆë‹¤.  

> ğŸ’¡ Javaì—ì„œ Mapì´ë¼ëŠ” ìë£Œêµ¬ì¡°ë¥¼ ì´ìš©í•˜ë©´ì„œ ë™ê¸°í™” ì˜¤ë²„í—¤ë“œì™€ ì„±ëŠ¥ ì €í•˜ë¥¼ ì¤„ì´ë©´ì„œ ìŠ¤ë ˆë“œ ì•ˆì „ì„±ì„ ìµœëŒ€í•œ ì±™ê¸¸ ìˆ˜ ì—†ì„ê¹Œ?  
>
> `ConcurrentHashMap` í´ë˜ìŠ¤ì— ëŒ€í•´ì„œ í•˜ë‚˜ì”© ì„¤ëª…í•˜ê³ ì í•œë‹¤.

<br>

ìš°ì„  `ConcurrentHashMap`ì€ ì½ê¸°ì— ëŒ€í•´ì„œëŠ” ë™ê¸°í™” ë¡œì§ì„ ì‹¤í–‰í•˜ì§€ ì•ŠëŠ”ë‹¤.  
ì´ìœ ëŠ” ë‚´ë¶€ í…Œì´ë¸”(`Node<K,V>[] table;`)ì´ `volatile`ë¡œ ì„ ì–¸ë˜ì–´ìˆì–´ì„œ ëª¨ë“  ì“°ê¸° ì‘ì—…ì€ í•´ë‹¹ ë³€ìˆ˜ì˜ ê°’ì„ ë©”ì¸ ë©”ëª¨ë¦¬ì— ì¦‰ì‹œ ë°˜ì˜í•˜ê³ , ëª¨ë“  ì½ê¸° ì‘ì—…ì€ ë©”ì¸ ë©”ëª¨ë¦¬ì—ì„œ ìµœì‹ ê°’ì„ ì½ì–´ì˜¤ë„ë¡ ë³´ì¥í•œë‹¤.  

í•œ ìŠ¤ë ˆë“œê°€ `put` ì‘ì—…ì„ í†µí•´ì„œ í…Œì´ë¸”ì˜ íŠ¹ì • ë²„í‚·ì„ ë³€ê²½í•˜ê±°ë‚˜ ë§µì˜ êµ¬ì¡°ë¥¼ ë³€ê²½í–ˆì„ ë•Œ, `volatile`ì— ì˜í•´ ê·¸ ë³€ê²½ ì‚¬í•­ì´ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ê²Œ ì¦‰ì‹œ ë³´ì—¬ì§ˆ ìˆ˜ ìˆë„ë¡ ë³´ì¥ë˜ëŠ” ê²ƒì´ë‹¤.

```java
//ConcurrentHashMap.java

transient volatile Node<K,V>[] table;

public V get(Object key) { // synchronized í‚¤ì›Œë“œê°€ ì—†ë‹¤.
    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;
    int h = spread(key.hashCode());
    if ((tab = table) != null && (n = tab.length) > 0 && (e = tabAt(tab, (n - 1) & h)) != null) {
        if ((eh = e.hash) == h) {
            if ((ek = e.key) == key || (ek != null && key.equals(ek)))
                    return e.val;
        }
        else if (eh < 0)
            return (p = e.find(h, key)) != null ? p.val : null;
        while ((e = e.next) != null) {
            if (e.hash == h && ((ek = e.key) == key || (ek != null && key.equals(ek))))
                return e.val;
        }
    }
    return null;
}
```

<br>

ê·¸ë¦¬ê³  `ConcurrentHashMap`ì˜ `put` ë©”ì†Œë“œì— ëŒ€í•œ ì½”ë“œë¥¼ ë³¸ ë’¤ì— ë™ê¸°í™” ê´€ë ¨ ë‚´ë¶€ ë¡œì§ì— ëŒ€í•œ ì„¤ëª…ì„ í•˜ê³ ì í•œë‹¤.

```java
//ConcurrentHashMap.java

public V put(K key, V value) {
    final int hash = spread(key.hashCode()); 
    int binCount = 0; // ë²„í‚·ì— ìˆëŠ” ë…¸ë“œ ìˆ˜

    for (Node<K,V>[] tab = table;;) { 
        Node<K,V> f; int n, i, fh;

        if (tab == null || (n = tab.length) == 0)
            tab = initTable(); // í…Œì´ë¸” ì´ˆê¸°í™” ë¡œì§ (CAS ì‚¬ìš©)
        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) { // íŠ¹ì • ë²„í‚·ì´ ë¹„ì–´ìˆìŒ
            if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null)))
                break; // CAS ì„±ê³µ, ë½ ì—†ì´ ë…¸ë“œ ì¶”ê°€ ì„±ê³µ!
        }
        else if ((fh = f.hash) == MOVED) 
            tab = helpTransfer(tab, f); 
        else { // ë²„í‚·ì— ë…¸ë“œê°€ ì´ë¯¸ ìˆëŠ” ê²½ìš° -> synchronized ë¸”ë¡ ì§„ì…
            V oldVal = null;
            synchronized (f) { // <-- ì´ ë¶€ë¶„ì´ í•µì‹¬! ë§µ ì „ì²´ê°€ ì•„ë‹Œ íŠ¹ì • ë²„í‚·ì—ë§Œ ë½
                if (tabAt(tab, i) == f) { // ë½ íšë“ í›„ì—ë„ í•´ë‹¹ ë…¸ë“œê°€ ì—¬ì „íˆ ì²« ë…¸ë“œì¸ì§€ í™•ì¸ (ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ë³€ê²½í–ˆì„ ìˆ˜ë„ ìˆìœ¼ë‹ˆ)
                    if (fh >= 0) { // ì¼ë°˜ ë…¸ë“œ (ì—°ê²° ë¦¬ìŠ¤íŠ¸)
                        binCount = 1;
                        for (Node<K,V> e = f;; ++binCount) {
                            K ek;
                            if (e.hash == hash &&
                                ((ek = e.key) == key ||
                                 (ek != null && key.equals(ek)))) {
                                oldVal = e.val;
                                // ë™ì¼ í‚¤ ë°œê²¬ ì‹œ ê°’ ì—…ë°ì´íŠ¸
                                e.val = value;
                                break;
                            }
                            Node<K,V> pred = e;
                            if ((e = e.next) == null) {
                                // ìƒˆ ë…¸ë“œ ì¶”ê°€ (ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ ëì—)
                                pred.next = new Node<K,V>(hash, key, value, null);
                                break;
                            }
                        }
                    } else if (f instanceof TreeBin) { // íŠ¸ë¦¬ ë…¸ë“œ (Red-Black Tree)
                        // TreeBin ë‚´ë¶€ ë¡œì§ìœ¼ë¡œ íŠ¸ë¦¬ì— ì‚½ì…/ì—…ë°ì´íŠ¸
                        oldVal = ((TreeBin<K,V>)f).putTreeVal(hash, key, value);
                    }
                }
            } // synchronized ë¸”ë¡ ë
            // binCountì— ë”°ë¼ íŠ¸ë¦¬ë¡œ ë³€í™˜í• ì§€ ê²°ì •
            if (binCount != 0) {
                if (binCount >= TREEIFY_THRESHOLD)
                    treeifyBin(tab, i); // ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ íŠ¸ë¦¬ë¡œ ë³€í™˜
                if (oldVal != null)
                    return oldVal;
                break;
            }
        }
    }
    addCount(1L, binCount);
    return null;
}
```

> ìœ„ ì½”ë“œì—ì„œ ìì„¸íˆ ë³´ë©´ HashMapì²˜ëŸ¼ ê°œë³„ ì²´ì´ë‹ ë°©ì‹ìœ¼ë¡œ êµ¬í˜„ë˜ì–´ìˆì–´ ë‚´ë¶€ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì˜ í¬ê¸°ê°€ ì¼ì • í¬ê¸° ì´ìƒì„ ë„˜ìœ¼ë©´ `treeify`ê°€ ë°œìƒí•´ì„œ êµ¬ì¡°ê°€ íŠ¸ë¦¬ í˜•íƒœë¡œ ë°”ë€ŒëŠ” ë¡œì§ì´ ë°œìƒí•˜ëŠ” ì ì€ ë˜‘ê°™ë‹¤.  
ğŸ’¡ í•˜ì§€ë§Œ `Hashtable`ì´ë‚˜ `Collections.synchronizedMap`ì²˜ëŸ¼ `put` ë©”ì†Œë“œ ìì²´ì— ë™ê¸°í™”ê°€ ì ìš©ë˜ì–´ ìˆì§€ ì•Šê³  ë²„í‚·ì— ê°’ì´ ìˆëŠ” ìƒíƒœë¼ë©´ Map ì „ì²´ì— ë½ì„ ê±¸ì§€ ì•Šê³  **'í•´ë‹¹ ë²„í‚·ì—ë§Œ'** ì ê¸ˆì„ ê±´ë‹¤.

ëª¨ë“  ë©”ì†Œë“œì—ì„œ ë½ ì²´í‚¹ì„ í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼ ë™ê¸°í™”ê°€ í•„ìš”í•  ë•Œì—ë§Œ í™•ì¸ ì‘ì—…ì„ í•˜ë„ë¡ êµ¬í˜„ë˜ì–´ìˆê¸° ë•Œë¬¸ì— ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ì¤€ìˆ˜í•œ ì„±ëŠ¥ì„ ê°€ì§€ë©´ì„œë„ Thread-safeí•  ìˆ˜ ìˆë‹¤.

<br>
<br>

# (ë²ˆì™¸) LinkedHashMapê³¼ LRU ìºì‹œì˜ ê´€ê³„

`LinkedHashMap`ì€ `HashMap`ê³¼ `LinkedList`ì˜ íŠ¹ì„±ì´ ê²°í•©ëœ í´ë˜ìŠ¤ì´ê³ , `HashMap`ì„ ìƒì†ë°›ê³  ìˆë‹¤.

ê¸°ë³¸ì ìœ¼ë¡œ `put`, `get` ë“± `HashMap`ì˜ ê¸°ë³¸ ì—°ì‚°ì— ëŒ€í•œ ì‹œê°„ ë³µì¡ë„ëŠ” í‰ê· ì ìœ¼ë¡œ O(1)ì˜ ë³µì¡ë„ë¥¼ ê°€ì§€ê³  ìˆê³  Thread-safeí•˜ì§€ ì•Šë‹¤. ë˜í•œ `null`ì„ í—ˆìš©í•œë‹¤.

í•˜ì§€ë§Œ í° íŠ¹ì§•ìœ¼ë¡œëŠ” **ì‚½ì… ìˆœì„œ ìœ ì§€**ë¥¼ ë“¤ ìˆ˜ ìˆë‹¤. `HashMap`ê³¼ì˜ ì£¼ìš” ì°¨ì´ì ì€ **ìš”ì†Œì˜ ì‚½ì… ìˆœì„œë¥¼ ìœ ì§€**í•œë‹¤ëŠ” ê²ƒì´ë‹¤. ë‚´ë¶€ `Entry`ê°€ ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸(doubly-linked list)ë¡œ ì´ë£¨ì–´ì ¸ ìˆì–´ì„œ Mapì— ìš”ì†Œë¥¼ ì¶”ê°€í•œ ìˆœì„œëŒ€ë¡œ ìˆœíšŒí•  ìˆ˜ ìˆë‹¤.

ê·¸ë¦¬ê³  **ì ‘ê·¼ ìˆœì„œ ìœ ì§€**ì˜ íŠ¹ì„±ë„ ê°€ì§€ê³  ìˆë‹¤.
ì‚½ì… ìˆœì„œì™€ ë³„ê°œë¡œ `get`ì´ë‚˜ `put` ë©”ì†Œë“œë¥¼ í†µí•´ íŠ¹ì • `Entry`ì— ì ‘ê·¼í•  ë•Œë§ˆë‹¤ í•´ë‹¹ ì—”íŠ¸ë¦¬ê°€ ê°€ì¥ ìµœê·¼ì— ì‚¬ìš©ëœ ìœ„ì¹˜ë¡œ ì´ë™í•œë‹¤.  
ì´ ì„¤ì •ì€ `LinkedHashMap` ë‚´ë¶€ì— `accessOrder` í•„ë“œë¥¼ `true`ë¡œ ì„¤ì •í•˜ë©´ ì ìš©ì´ ëœë‹¤.  

ğŸ’¡ `Entry`ëŠ” Map ë‚´ë¶€ì˜ (í‚¤-ê°’) ìŒì„ ì˜ë¯¸í•œë‹¤.

<br>

> ìœ„ì™€ ê°™ì€ íŠ¹ì„±ì„ ì´ìš©í•˜ë©´ **LRU ìºì‹œ**ë‚˜ **ìˆœì„œê°€ ì¤‘ìš”í•œ Map**ì„ êµ¬í˜„í•  ë•Œ `LinkedHashMap`ì„ ì´ìš©í•˜ë©´ ìœ ìš©í•˜ë‹¤.

ì‹¤ì œë¡œ LRU ìºì‹œë¥¼ êµ¬í˜„í•´ì•¼í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ([LeetCode - LRU Cache](https://leetcode.com/problems/lru-cache/description/))ì—ì„œ ìœ ìš©í•˜ê²Œ ì‚¬ìš©í–ˆë‹¤.

ì´ ë¬¸ì œì—ì„œëŠ” ìš©ëŸ‰ì´ ì •í•´ì ¸ìˆëŠ” LRU ìºì‹œë¥¼ êµ¬í˜„í•´ì•¼í–ˆê³ , ìš©ëŸ‰ì„ ë„˜ê²Œëœë‹¤ë©´ ì ‘ê·¼ì´ ì˜¤ë˜ëœ ê°ì²´ë¥¼ ì œê±°í•´ì•¼í•˜ëŠ” ì¡°ê±´ì„ ê°€ì¡Œë‹¤. ì´ë¥¼ ì•„ë˜ì™€ ê°™ì´ `LinkedHashMap`ì„ ìƒì† ë°›ì•„ì„œ êµ¬í˜„í–ˆë‹¤.

```java
class LRUCache{
    Map<Integer, Integer> cacheMap;
    public LRUCache(int capacity) {
        cacheMap = new LRUCacheMap<>(capacity, true);
    }

    public int get(int key) {
        return Objects.isNull(cacheMap.get(key)) ? -1 : cacheMap.get(key);
    }

    public void put(int key, int value) {
        cacheMap.put(key, value);
    }

    class LRUCacheMap<K, V> extends LinkedHashMap<K, V>{
        private int MAX_ENTRIES;
        public LRUCacheMap(int initialCapacity, boolean accessOrder){
            super(initialCapacity, 0.75f, accessOrder);
            MAX_ENTRIES = initialCapacity;
        }

        @Override
        protected boolean removeEldestEntry(Map.Entry eldest) {
            return size() > MAX_ENTRIES;
        }
    }
}
```

ìƒì† ë°›ì„ ë•Œ ë¬¸ì œì—ì„œ ì…ë ¥ ë°›ì„ ìš©ëŸ‰ê³¼ `accessOrder = true` ì •ë³´ë¥¼ ë‹´ì•„ì„œ `LinkedHashMap`ì„ ìƒì„±í•´ì•¼í•œë‹¤.
ê·¸ë¦¬ê³  LRU ìºì‹œì—ì„œ ì›í•˜ëŠ” ëŒ€ë¡œ ì ‘ê·¼ì´ ì˜¤ë˜ëœ `Entry`ë¥¼ ì œê±°í•˜ëŠ” ë¡œì§ì€ ì§ì ‘ êµ¬í˜„í•´ì£¼ì–´ì•¼í•œë‹¤ê³  ì˜ˆì‹œì™€ í•¨ê»˜ `LinkedHashMap.java`ì— ì í˜€ìˆë‹¤.

<div style="text-align: center;">
    <img src="../assets/img/develop/LinkedHashMap_removeEldestEntry.png" alt="hash_basic" width="500">
</div>

<br>
<br>

## ê²°ë¡ 

Javaì—ì„œì˜ Hash, HashMapê³¼ ìŠ¤ë ˆë“œ ì•ˆì „ì„±, ìˆœì„œê°€ ë³´ì¥ëœ Mapì— ëŒ€í•œ ë¶€ë¶„ì„ ê³µë¶€í–ˆë‹¤. í•´ì‹œ í•¨ìˆ˜ì— ì ìš©ë˜ëŠ” í™•ë¥ ì ì¸ ìë£Œêµ¬ì¡°ì´ê³  ì–´ë ¤ìš´ Bloom Filterë„ ê³µë¶€í•´ë³¼ ê³„íšì´ë‹¤.

## ì¶œì²˜

- `HashMap.java`
- `LinkedHashMap.java`
- `ConcurrentHashMap.java`
- `Collections.java`
